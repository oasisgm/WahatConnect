import talib
import pandas as pd
import numpy as np
import speech_recognition as sr
import openai
from kiteconnect import KiteConnect
from datetime import datetime, timedelta
import logging
import os
import re
import time

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Secure API keys
API_KEY = os.getenv("KITE_API_KEY")
API_SECRET = os.getenv("KITE_API_SECRET")
openai.api_key = os.getenv("OPENAI_API_KEY")

# Initialize KiteConnect
kite = KiteConnect(api_key=API_KEY)

# Function to get request token securely
def fetch_and_set_access_token(api_key, api_secret):
    """Fetches a new access token and sets it for KiteConnect."""
    request_token = input("Enter your request token: ")
    try:
        data = kite.generate_session(request_token, api_secret=api_secret)
        access_token = data["access_token"]
        kite.set_access_token(access_token)
        with open("access_token.txt", "w") as f:
            f.write(access_token)
        logging.info("Access token fetched and set successfully.")
    except Exception as e:
        logging.error(f"Error fetching access token: {e}")
        raise

# Load or refresh access token
try:
    with open("access_token.txt", "r") as f:
        access_token = f.read().strip()
        kite.set_access_token(access_token)
        logging.info("Access token loaded from file.")
except FileNotFoundError:
    logging.warning("Access token file not found. Fetching a new token.")
    fetch_and_set_access_token(API_KEY, API_SECRET)
except Exception as e:
    logging.error("Error setting access token. Refreshing token.")
    fetch_and_set_access_token(API_KEY, API_SECRET)

# Function to fetch historical stock data
def get_full_stock_history(symbol, interval="day"):
    """Fetches all available historical stock data."""
    try:
        instrument = kite.ltp(f"NSE:{symbol}")
        instrument_token = instrument[f"NSE:{symbol}"]["instrument_token"]
    except Exception as e:
        logging.error(f"Error fetching instrument token for {symbol}: {e}")
        return pd.DataFrame()
    
    full_data = pd.DataFrame()
    end_date = datetime.now()
    start_date = end_date - timedelta(days=3650)
    delta = timedelta(days=2000) if interval in ["day", "week", "month"] else timedelta(days=30)
    
    while start_date < end_date:
        next_date = min(start_date + delta, end_date)
        try:
            data = kite.historical_data(instrument_token, start_date, next_date, interval)
            df = pd.DataFrame(data)
            full_data = pd.concat([full_data, df], ignore_index=True)
        except Exception as e:
            logging.error(f"Error fetching data from {start_date} to {next_date}: {e}")
            break
        start_date = next_date
    
    logging.info(f"Fetched {len(full_data)} records for {symbol}.")
    return full_data

# Function to apply technical indicators
def apply_technical_indicators(df):
    """Calculates RSI, MACD, and SMA."""
    logging.info("Applying technical indicators.")
    if df.empty:
        return df
    try:
        df.fillna(method="ffill", inplace=True)
        df["RSI"] = talib.RSI(df["close"], timeperiod=14)
        df["MACD"], df["MACD_signal"], _ = talib.MACD(df["close"])
        df["SMA"] = talib.SMA(df["close"], timeperiod=50)
    except Exception as e:
        logging.error(f"Error applying technical indicators: {e}")
    return df

# AI-based trade recommendation
def ai_trade_recommendation(df):
    """Provides AI-generated trade recommendations."""
    logging.info("Generating AI-based trade recommendation.")
    if df.empty:
        return "No data available."
    latest = df.iloc[-1]
    risk_reward_ratio = 2
    stop_loss = latest["close"] * 0.97
    take_profit = latest["close"] * 1.06
    
    if latest["RSI"] < 30 and latest["MACD"] > latest["MACD_signal"]:
        return f"ðŸ”¹ Strong Buy | SL: â‚¹{stop_loss:.2f} | TP: â‚¹{take_profit:.2f}"
    elif latest["RSI"] > 70 and latest["MACD"] < latest["MACD_signal"]:
        return f"ðŸ”» Strong Sell | SL: â‚¹{stop_loss:.2f} | TP: â‚¹{take_profit:.2f}"
    return "âš ï¸ No clear trend. Hold."

# Function to execute trade
def execute_trade(symbol, quantity, order_type):
    """Executes trade using KiteConnect."""
    try:
        order_id = kite.place_order(
            variety=kite.VARIETY_REGULAR,
            exchange=kite.EXCHANGE_NSE,
            tradingsymbol=symbol,
            transaction_type=order_type,
            quantity=quantity,
            order_type=kite.ORDER_TYPE_MARKET,
            product=kite.PRODUCT_MIS
        )
        logging.info(f"Trade Executed! Order ID: {order_id}")
        return order_id
    except Exception as e:
        logging.error(f"Trade failed: {e}")
        return None

# Voice command trading
def voice_command_trading():
    """Allows users to place trades via voice commands."""
    recognizer = sr.Recognizer()
    with sr.Microphone() as source:
        logging.info("ðŸŽ™ï¸ Listening for trade command...")
        audio = recognizer.listen(source)
    
    try:
        command = recognizer.recognize_google(audio).lower()
        logging.info(f"Recognized command: {command}")
        match = re.search(r"(buy|sell) (\d+) shares of (\w+)", command)
        if match:
            action, quantity, stock = match.groups()
            quantity = int(quantity)
            order_type = kite.TRANSACTION_TYPE_BUY if action == "buy" else kite.TRANSACTION_TYPE_SELL
            return execute_trade(stock.upper(), quantity, order_type)
        logging.info("No valid command detected.")
    except sr.UnknownValueError:
        logging.error("Could not understand the command.")
    except sr.RequestError as e:
        logging.error(f"Speech recognition request failed: {e}")

# Example usage
if __name__ == "__main__":
    df = get_full_stock_history("INFY")
    df = apply_technical_indicators(df)
    print(ai_trade_recommendation(df))
    voice_command_trading()

 
